<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker运行Nginx容器</title>
    <url>/2020/10/27/Docker%E8%BF%90%E8%A1%8CNginx%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p><strong>整体步骤：</strong></p>
<ol>
<li>创建并运行容器，且在nginx容器创建时向宿主机挂载出一个空文件夹。</li>
<li>进入容器将conf.d移动到向宿主机挂载的空文件夹中。</li>
<li>进入向宿主机挂载的空文件夹中，并将conf.d软连接到其原本所在的目录。</li>
</ol>
<h2 id="拉取nginx镜像"><a href="#拉取nginx镜像" class="headerlink" title="拉取nginx镜像"></a>拉取nginx镜像</h2><ul>
<li>先<code>推荐个网站</code>，从你开始使用docker就要必备的——<a href="https://hub.docker.com/">DockerHub</a>。一句话说明就是一个镜像大全。</li>
<li><code>寻找镜像资源</code>的话就在上面那个网站上搜索就行，版本、下载方式自选。</li>
<li><code>拉取镜像</code>的话在上面那个网站搜索后，拉取命令<code>docker pull nginx</code>直接给你了，且nginx无须在意版本，直接拉last版本即可。<img src="http://qn.mfei.fun/img/image-20220919151601854.png" alt="image-20220919151601854"></li>
</ul>
<h2 id="创建配置路径"><a href="#创建配置路径" class="headerlink" title="创建配置路径"></a>创建配置路径</h2><p>如果你选择容器管理nginx服务的话，请先不要着急启动，先<code>在宿主机新建一个文件夹</code>，这将是你之后<code>存放nginx配置</code>的地方。</p>
<h2 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h2><ul>
<li><p>控制台执行<code>docker images</code>检查镜像是否存在。</p>
</li>
<li><p>配置启动命令（创建容器很简单，但是想要好用，需要认真配置）</p>
<blockquote>
<p>最终命令：<code>docker run --name nginx-first -p 90:80 -v /var/dps/nginx:/nginx -d nginx</code></p>
<blockquote>
<p>解释：</p>
<p><code>docker run nginx</code>，为生成nginx镜像的容器。<br><code>--name nginx-first</code>，指定容器名称为nginx-first。<br><code>-p 90:80</code>，指将容器中80端口映射到宿主机90端口。</p>
<p><code>-v /var/dps/nginx:/nginx</code>，指将容器中nginx某一文件夹<a href="https://so.csdn.net/so/search?q=%E6%8C%82%E8%BD%BD&spm=1001.2101.3001.7020">挂载</a>到宿主机某一文件夹（左边为宿主机文件夹地址）。</p>
<p><code>-d</code>，表示后台运行该容器。</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="设置nginx配置"><a href="#设置nginx配置" class="headerlink" title="设置nginx配置"></a>设置nginx配置</h2><ul>
<li><p>将容器中nginx默认<code>conf.d配置文件夹移动到</code>启动容器命令中预设的<code>挂载目录</code>中。</p>
<blockquote>
<ol>
<li>查看容器<code>docker ps</code>，进入容器<code>docker exec -it [容器id] /bin/bash</code>。</li>
<li>cd到&#x2F;etc&#x2F;nginx目录中<code>cd /etc/nginx</code>。</li>
<li>再将该文件夹下conf.d文件夹移动到你预设的挂载目录中<code>rm /etc/nginx/conf.d /nginx</code>。</li>
</ol>
</blockquote>
</li>
<li><p>来到启动容器命令中预设的挂载目录中，<code>检查是否存在conf.d文件夹</code>。</p>
</li>
<li><p>在预设的挂载目录中，将conf.d文件夹软连接到其原本的位置<code>ln -s /nginx/conf.d /etc/nginx</code>。</p>
</li>
<li><p>此时即可在<code>宿主机的挂载目录中操作</code>nginx容器的default.conf文件或者<code>新增配置文件</code>了。</p>
</li>
</ul>
<h3 id="nginx配置文件在哪里？"><a href="#nginx配置文件在哪里？" class="headerlink" title="nginx配置文件在哪里？"></a>nginx配置文件在哪里？</h3><ul>
<li>nginx的配置文件默认是在<code>etc/nginx</code>文件夹下，该文件夹下有<code>nginx.conf</code>、<code>conf.d</code>两个配置文件夹，一般我们自定义的配置是要放在<code>conf.d</code>中的，故只需将<code>cong.d</code>挂载到宿主机即可。</li>
<li>如果你非想在自己去找找看，直接执行<code>docker run -d nginx</code></li>
</ul>
<h3 id="为什么不直接将nginx配置文件挂载出来？"><a href="#为什么不直接将nginx配置文件挂载出来？" class="headerlink" title="为什么不直接将nginx配置文件挂载出来？"></a>为什么不直接将nginx配置文件挂载出来？</h3><p>我们既然知道了容器中nginx的conf.d文件夹位置，为什么<code>不直接将其挂载出来</code>，反而要多此一举搞个<a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E8%BF%9E%E6%8E%A5&spm=1001.2101.3001.7020">软连接</a>？其实也不是不行，只是如果我们一上来就拿个空文件夹来挂载conf.d文件夹，会造成<code>覆盖</code>，使容器中conf.d文件夹也变成空文件夹，<code>间接删除了原有的default.conf文件</code>，我们还要从其他地方拷一个default.conf过来。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb——Servlet</title>
    <url>/2020/10/09/JavaWeb%E2%80%94%E2%80%94Servlet/</url>
    <content><![CDATA[<h2 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h2><p><span style="color:red">Servlet通常指的就是实现Servlet接口的java类，通过对http请求进行处理并响应结果，用以开发动态web。</span></p>
<ul>
<li><code>Servlet</code>是sun公司<code>开发动态web的一门技术</code>。</li>
<li>通常把<code>实现了Servlet接口</code>的Java程序叫做Servlet。</li>
<li>Servlet在sun公司有两个默认实现类<code>HttpServlet</code>和<code>GenericServlet</code></li>
<li>HttpServlet类继承GenericServlet类，GenericServlet类继承Servlet接口，故我们的类只需要继承<code>HttpServlet</code>类即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// ServletOutputStream outputStream = resp.getOutputStream();</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter(); <span class="comment">// 响应流</span></span><br><span class="line">        writer.println(<span class="string">&quot;Hello,Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet工作原理"><a href="#Servlet工作原理" class="headerlink" title="Servlet工作原理"></a>Servlet工作原理</h2><p><img src="http://qn.mfei.fun/img/I2@9KQ%7B9UPO[@%Q%FR1%7D~AQ.png" alt="img"></p>
<p>用户在上网时，由客户端浏览器<code>发送http请求</code>至服务器，服务器根据用户请求方式及地址从磁盘中<code>加载对应的Servlet程序文件</code>到Servlet容器。服务器<code>解析http请求为request对象</code>，<code>转发request对象到相应Servlet中</code>进行处理，Servlet<code>处理后返回response对象</code>，服务器再<code>将response对象转为http响应</code>，响应给客户端浏览器。</p>
<h2 id="编写Servlet映射"><a href="#编写Servlet映射" class="headerlink" title="编写Servlet映射"></a>编写Servlet映射</h2><p><span style="color:red">要通过浏览器访问java程序，而浏览器需要连接web服务器，所以需要在web服务中注册Servlet，还要给它一个浏览器能够访问的路径。</span></p>
<h4 id="注册方式一"><a href="#注册方式一" class="headerlink" title="注册方式一"></a>注册方式一</h4><p><code>@WebServlet注解</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test只是个名字而已，value为访问地址</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;test&quot;, value = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// ServletOutputStream outputStream = resp.getOutputStream();</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter(); <span class="comment">// 响应流</span></span><br><span class="line">        writer.println(<span class="string">&quot;Hello,Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册方式二"><a href="#注册方式二" class="headerlink" title="注册方式二"></a>注册方式二</h4><p><code>web.xml</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;!--web.xml中是配置web的核心应用--&gt;</span><br><span class="line">  &lt;!--注册Servlet--&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;!--Servlet名字--&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpenceServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--Servlet指向的类--&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.spence.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--一个Servlet对应一个Mapping：映射--&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;!--通过名字绑定一个Servlet--&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpenceServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--该Servlet的请求地址--&gt;</span><br><span class="line">    &lt;url-pattern&gt;/spence&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<p>注意：<code>&lt;servlet-mapping&gt;</code>标签与<code>&lt;servlet&gt;</code>标签一一对应，且<code>&lt;servlet&gt;标签要在&lt;servlet-mapping&gt;标签上面</code>。</p>
<h2 id="Servlet核心对象"><a href="#Servlet核心对象" class="headerlink" title="Servlet核心对象"></a>Servlet核心对象</h2><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p><span style="color:red">ServletContext是上下文对象，用于管理整个web应用</span></p>
<p>web容器在启动时，会为每个web程序（每个Service）都创建一个对应的ServletContext对象，<code>它代表当前web应用</code>。但要注意，<code>每个web程序（Servlet类）中创建的ServletContext对象其实是同一个对象</code>，因此可通过ServletContext对象使得各个Servlet类中的数据互通共享（ServletContext对象凌驾于所有Servlet类之上，它是<code>由web容器（服务器）创建的</code>）。</p>
<h4 id="应用场景——资源共享"><a href="#应用场景——资源共享" class="headerlink" title="应用场景——资源共享"></a>应用场景——资源共享</h4><p><code>向ServletContext对象中存入数据</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;哥哥&quot;</span>;</span><br><span class="line">        <span class="comment">// 将一个数据以键值对形式保存在了 servletContext 中</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;userName&quot;</span>, userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>从ServletContext对象中取出对象</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> (String) servletContext.getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.println(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景——获取初始化参数"><a href="#应用场景——获取初始化参数" class="headerlink" title="应用场景——获取初始化参数"></a>应用场景——获取初始化参数</h4><p><code>可在web.xml配置文件中写入一些初始化参数</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>jdbc_url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>通过ServletContext对象中getInitParameter方法读取初始化参数</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;jdbc_url&quot;</span>); <span class="comment">// 读入初始化参数</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    writer.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景——请求转发"><a href="#应用场景——请求转发" class="headerlink" title="应用场景——请求转发"></a>应用场景——请求转发</h4><p><span style="color:red">通过ServletContext对象中getRequestDispatcher方法写入转发请求路径，再通过RequestDispatcher对象的forward方法实现转发。相当于指明一个新的请求路径，把请求和响应参数传入到新的请求中（该种情况不同于重定向，不会改变浏览器页中URL地址）。</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">    <span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> servletContext.getRequestDispatcher(<span class="string">&quot;/jdbc&quot;</span>); <span class="comment">// 转发的请求路径</span></span><br><span class="line">    requestDispatcher.forward(req, resp); <span class="comment">// 调用forward实现转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景——读取资源文件"><a href="#应用场景——读取资源文件" class="headerlink" title="应用场景——读取资源文件"></a>应用场景——读取资源文件</h4><p>想办法搞出一个文件流即可。</p>
<ul>
<li>在java目录下新建properties文件</li>
<li>在resources目录下新建properties文件</li>
</ul>
<p>发现：都被打包到了同一个路径下—&gt; class，我们俗称这个路径为classpath。</p>
<p><code>在resources目录下新建 db.properties 文件</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><code>通过ServletContext对象中 getResourceAsStream 方法读取文件</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">    <span class="comment">// 通过 getResourceAsStream 方法读取文件  /WEB-INF/classes/db.properties 为打包后文件所在相对路径</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">iStream</span> <span class="operator">=</span> servletContext.getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>); <span class="comment">// File流为绝对路径，在线上不方便使用</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.load(iStream);</span><br><span class="line">    <span class="comment">// 获取配置文件中信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    writer.println(username +<span class="string">&quot;:&quot;</span>+ password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>web服务器收到客户端http请求后，针对该请求分别创建一个代表请求的HttpServletRequest对象，和一个<code>代表响应的HttpServletResponse对象</code>。</p>
<ul>
<li>如果要获取客户端请求过来的数据：去HttpServletRequest对象中找</li>
<li>如果要给客户端响应过去一些数据：向HttpServletRequest对象添加</li>
</ul>
<p><code>负责向浏览器发送数据的方法：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平常的流</span></span><br><span class="line">ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 字符</span></span><br><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p><code>负责向浏览器发送一些响应头的方法</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置响应的编码</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCharacterEncoding</span><span class="params">(String var1)</span>;</span><br><span class="line"><span class="comment">// 设置响应字符串长度</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContentLength</span><span class="params">(<span class="type">int</span> var1)</span>;</span><br><span class="line"><span class="comment">// 设置流长度</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContentLengthLong</span><span class="params">(<span class="type">long</span> var1)</span>;</span><br><span class="line"><span class="comment">// 设置类型</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContentType</span><span class="params">(String var1)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="应用场景——-向浏览器输出消息"><a href="#应用场景——-向浏览器输出消息" class="headerlink" title="应用场景—— 向浏览器输出消息"></a>应用场景—— 向浏览器输出消息</h4><p>getOutputStream、getWriter等</p>
<h4 id="应用场景——验证码功能"><a href="#应用场景——验证码功能" class="headerlink" title="应用场景——验证码功能"></a>应用场景——验证码功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 让浏览器3秒自动刷新一次</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;refresh&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="comment">// 在内存中创建一个图片</span></span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(<span class="number">80</span>, <span class="number">20</span>, BufferedImage.TYPE_INT_BGR);</span><br><span class="line">    <span class="comment">// 得到图片</span></span><br><span class="line">    <span class="type">Graphics2D</span> <span class="variable">g</span> <span class="operator">=</span> (Graphics2D)image.getGraphics(); <span class="comment">// 画笔</span></span><br><span class="line">    <span class="comment">// 设置画笔颜色</span></span><br><span class="line">    g.setColor(Color.PINK);</span><br><span class="line">    <span class="comment">// 给图片填充数据</span></span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 给图片写入数据</span></span><br><span class="line">    g.setColor(Color.BLUE);</span><br><span class="line">    g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="literal">null</span>, Font.BOLD, <span class="number">20</span>));</span><br><span class="line">    g.drawString(makeNum(), <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 告诉浏览器，这个请求用图片的方式打开</span></span><br><span class="line">    resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="comment">// 不让浏览器缓存</span></span><br><span class="line">    resp.setDateHeader(<span class="string">&quot;expires&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    <span class="comment">// 把图片写给浏览器</span></span><br><span class="line">    ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, resp.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">makeNum</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">9999999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>-num.length(); i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString()+num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景——下载文件"><a href="#应用场景——下载文件" class="headerlink" title="应用场景——下载文件"></a>应用场景——下载文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 获取要下载文件的路径</span><br><span class="line"><span class="number">2.</span> 下载的文件名</span><br><span class="line"><span class="number">3.</span> 让浏览器能够支持所需下载的东西</span><br><span class="line"><span class="number">4.</span> 创建下载文件的输入流</span><br><span class="line"><span class="number">5.</span> 创建缓冲区</span><br><span class="line"><span class="number">6.</span> 获取OutputStream对象</span><br><span class="line"><span class="number">7.</span> 将FileOutputStream流写入到buffer缓冲区，使用OutputStream将缓冲区中的数据输出到客户端</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 获取要下载文件的路径</span></span><br><span class="line">    <span class="comment">// String realPath = this.getServletContext().getRealPath(&quot;/pic_01.png&quot;);</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\IDEA_WorkSpace\\my-demo\\maven-03-web\\web-03-test\\src\\main\\resources\\static\\img\\pic_01.png&quot;</span>;</span><br><span class="line">    <span class="comment">// 2. 下载的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="string">&quot;//&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 让浏览器能够支持所需下载的东西</span></span><br><span class="line">    <span class="comment">// resp.setHeader(&quot;content-disposition&quot;, &quot;attachment;fileName&quot;+fileName);</span></span><br><span class="line">    <span class="comment">// 中文文件名用 URLEncoder.encode 编码，否则有可能乱码</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span>+ URLEncoder.encode(fileName, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">    <span class="comment">// 4. 创建下载文件的输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">// 5. 创建缓冲区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 6. 获取OutputStream对象</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">    <span class="comment">// 7. 将FileOutputStream流写入到buffer缓冲区，使用OutputStream将缓冲区中的数据输出到客户端</span></span><br><span class="line">    <span class="keyword">while</span> ((len = fileInputStream.read(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        outputStream.write(buffer,<span class="number">0</span> , len);</span><br><span class="line">    &#125;</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景——实现重定向"><a href="#应用场景——实现重定向" class="headerlink" title="应用场景——实现重定向"></a>应用场景——实现重定向</h4><p><span style="color:red">一个web资源收到客户端请求后，他会通知客户端去访问另外一个web资源，这个过程叫重定向（该过程不同于转发，客户端浏览器中URL会发生改变）。</span></p>
<p><code>常见场景</code>：用户登录<br><code>重定向方法</code>：void sendRedirect(String var1) throws IOException;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;/test3/image&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resp.sendRedirect(&quot;/test3/image&quot;);</span></span><br><span class="line"><span class="comment">     * 等价于</span></span><br><span class="line"><span class="comment">     * resp.setHeader(&quot;Location&quot;, &quot;/test3/image&quot;);</span></span><br><span class="line"><span class="comment">     * resp.setStatus(302);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest代表客户端请求，用户通过Http协议访问服务器，<code>Http请求中的所有信息会被封装到HttpServletRequest</code>，通过这个HttpServletRequest的方法，获得客户端的所有信息。</p>
<h4 id="应用场景——获取前端传递的参数、请求转发"><a href="#应用场景——获取前端传递的参数、请求转发" class="headerlink" title="应用场景——获取前端传递的参数、请求转发"></a>应用场景——获取前端传递的参数、<strong>请求转发</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getParameter</span><span class="params">(String var1)</span>;</span><br><span class="line">String[] getParameterValues(String var1);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String[] hobbies = req.getParameterValues(<span class="string">&quot;hobbies&quot;</span>);</span><br><span class="line">	<span class="comment">// 这里的 / 代表当前的web应用</span></span><br><span class="line">    req.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>java.lang.NoClassDefFoundError javaxservlethttpHttpServlet</title>
    <url>/2020/09/30/java.lang.NoClassDefFoundError%20javaxservlethttpHttpServlet/</url>
    <content><![CDATA[<p><code>java.lang.NoClassDefFoundError: javax/servlet/http/HttpServlet</code></p>
<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>最近对JavaWeb进行了简单复习，在对照以往笔记写好了一个<a href="https://so.csdn.net/so/search?q=Servlet&spm=1001.2101.3001.7020">Servlet</a>服务时发现无法启动该项目服务。针对<code>java.lang.NoClassDefFoundError: javax/servlet/http/HttpServlet</code>这个问题，百度结果有让<code>导jar包</code>的、有让<code>提升IDEA版本</code>的、有让<code>重装Tomcat</code>的，也有让<code>修改项目中web.xml</code>的，有些方法一看就不靠谱，于是我便尝试修改项目中web.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>版本，发现依旧不行，但从中却获得了灵感。</p>
<h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>Tomcat原码是基于java，于是乎便联想到了<code>Servlet</code>、<code>Tomcat</code>、<code>jdk</code>之间是否存在着<code>版本关联</code>。果然在对Tomcat配置文件以及新建web项目时引入Servlet依赖版本分析时发现了问题。</p>
<h4 id="jdk与Tomcat"><a href="#jdk与Tomcat" class="headerlink" title="jdk与Tomcat"></a>jdk与Tomcat</h4><p>目前项目开发常用的jdk版本依旧为1.8，而我最先选用的Tomcat版本为10.0.12，那么问题来了，<code>2014</code>年发布的<code>jdk1.8</code>和<code>2020</code>年发布的<code>Tomcat10.0.0</code>他们它们可以兼容吗？我们新建项目一步步的看：</p>
<p><img src="http://qn.mfei.fun/img/image-20220919145214496.png" alt="image-20220919145214496"></p>
<p>不难发现<code>jdk1.8的Servlet支持版本为4.0.1</code></p>
<p><img src="http://qn.mfei.fun/img/Q%A%7B[VOX5%7BPWX@I$~9GODLN.hc" alt="img"></p>
<p>而我们去Tomcat下载目录里看10版本以上的Tomcat所使用的的Servlet版本</p>
<p><img src="http://qn.mfei.fun/img/BJ$K_H2%7BW%7DWWP$QV7W%DK1E.hc" alt="img"></p>
<p><img src="http://qn.mfei.fun/img/image-20220919145326075.png" alt="image-20220919145326075"></p>
<p>得出结论，<code>jdk1.8所依赖的Servlet版本为4.0，而Tomcat10.0.12依赖的Servlet版本为5.0，二者不匹配！</code><br>此时我们尝试将jdk版本由8上调至9：</p>
<p><img src="http://qn.mfei.fun/img/image-20220919145352384.png" alt="image-20220919145352384"></p>
<p>发现jdk对Servlet依赖版本变成了5.0.0。但是改动jdk版本并不是我们的本意，此时就需要<code>考虑降低Tomcat配置，使其匹配当前jdk</code>。<br>观察Tomcat9.0.54版本的配置文件：</p>
<p><img src="http://qn.mfei.fun/img/$Y%60ECGS$JBA0C%5DL8W~JR63J.png" alt="img"></p>
<p><img src="http://qn.mfei.fun/img/YHR@ZEQRP8HE0N4VDV0JG68.hc" alt="img"></p>
<p>发现Tomcat9.0.54版本所依赖的Servlet版本为4.0</p>
<h3 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p><code>降低Tomcat版本</code>使其依赖的Servlet版本与jdk所依赖的Servlet版本相匹配。</p>
<p><img src="http://qn.mfei.fun/img/image-20220919145605802.png" alt="image-20220919145605802"></p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><code>提升jdk版本</code>，目的同样是使Tomcat依赖的Servlet版本与jdk所依赖的Servlet版本相匹配</p>
<p><img src="http://qn.mfei.fun/img/image-20220919145629935.png" alt="image-20220919145629935"></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在解决此问题时尽可能不要改动jdk版本。另外为了避免不必要麻烦，<code>项目中的web.xml头文件尽可能和Tomcat保持一致</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处为Tomcat9.0.54版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置信息</title>
    <url>/2020/09/15/Nginx%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>在nginx的文件目录<code>etc/nginx</code>下，有一个<code>nginx.conf</code>文件和一个<code>conf.d</code>文件夹。</p>
<h2 id="nginx-conf文件"><a href="#nginx-conf文件" class="headerlink" title="nginx.conf文件"></a><a href="https://so.csdn.net/so/search?q=nginx&spm=1001.2101.3001.7020">nginx</a>.conf文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个配置文件看得出以下信息：</p>
<ul>
<li>日志位置：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</li>
<li>最大连接数（默认）：1024</li>
<li><code>文件引入断言：/etc/nginx/conf.d/*.conf</code></li>
</ul>
<h2 id="conf-d文件夹"><a href="#conf-d文件夹" class="headerlink" title="conf.d文件夹"></a>conf.d文件夹</h2><ul>
<li>在该文件夹下有一个<code>default.conf</code>文件为nginx默认配置</li>
<li>根据<code>nginx.conf</code>文件中的配置断言看得出，自定义配置也应当放在<code>conf.d</code>文件夹中</li>
</ul>
<h2 id="default-conf文件"><a href="#default-conf文件" class="headerlink" title="default.conf文件"></a>default.conf文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html/nginx_reload;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /index.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html/nginx_reload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此结合<code>nginx.conf</code>文件和<code>default.conf</code>文件不难看出nginx的配置结构为以下这种情况：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#全局块</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#events块</span><br><span class="line">events &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#http块</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">	#http全局块</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    #server块</span><br><span class="line">    server</span><br><span class="line">    &#123; </span><br><span class="line">    	#server全局块</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">		#location块</span><br><span class="line">        location [PATTERN]</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    #http全局块</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li>events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li>http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li>server块：配置虚拟主机的相关参数，一个http中可以有多个server</li>
<li>location块：配置请求的路由，以及各种页面的处理情况。</li>
</ul>
<h2 id="配置server块"><a href="#配置server块" class="headerlink" title="配置server块"></a>配置server块</h2><p>我们在部署项目时最常配置的就是如default.conf文件所示的server块的配置。基本就是<code>监听一个端口</code>，当请求nginx主机ip+端口时自然就进入了监听该端口的server；<code>监听一个地址</code>，该地址为当前server服务所在地址；<code>对请求路由</code>，即对请求的URL进行过滤匹配，访问具体的静态资源或服务。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">        listen       4545;   #监听端口</span><br><span class="line">        server_name  127.0.0.1;   #监听地址       </span><br><span class="line">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line">           #root path;  #根目录</span><br><span class="line">           #index vv.txt;  #设置默认页</span><br><span class="line">           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表</span><br><span class="line">           deny 127.0.0.1;  #拒绝的ip</span><br><span class="line">           allow 172.18.5.54; #允许的ip           </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>路由静态资源</strong><br>当请求静态资源时，路由方式如下（因为nginx首页内容即为前端静态资源，故此出以default.nginx对首页资源的路由举例）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /usr/share/nginx/html/nginx_reload;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路由服务地址</strong><br>当请求后端服务时，路由方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">    server 172.17.0.4:8000;</span><br><span class="line">    server 172.17.0.5:8000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /api &#123;</span><br><span class="line">   proxy_pass http://myserver;</span><br><span class="line">   index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="root与alias"><a href="#root与alias" class="headerlink" title="root与alias"></a>root与alias</h2><p><strong>root</strong><br>root是用来指定访问资源的文件路径的，nginx会<code>将root的值和location的值进行拼接</code>，然后<code>再拼接上url剩余的部分及index指定的值</code>。</p>
<figure class="highlight plaintext"><figcaption><span>/login/&#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">location /login/&#123;</span><br><span class="line">    root    /usr/local;</span><br><span class="line">    index    index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/login --&gt; /usr/local/login/index.html</span><br><span class="line">/login/b --&gt; /usr/local/login/b/index.html</span><br></pre></td></tr></table></figure>

<p><strong>alias</strong><br>alias也是用来指定访问资源的文件路径的，但是nginx会<code>将alias的值替换location的值</code>，然后<code>再拼接上url剩余的部分及index指定的值</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">location /login/&#123;</span><br><span class="line">    alias    /usr/local;</span><br><span class="line">    index    index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/login --&gt; /usr/local/index.html</span><br><span class="line">/login/b --&gt; /usr/local/b/index.html</span><br></pre></td></tr></table></figure>

<p>另外：alias指定的是文件夹路径，不能直接指定到具体的文件，否则会500，例如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">location /login/&#123;</span><br><span class="line">    alias    /usr/local/index.html;</span><br><span class="line">    #index    index.html;</span><br><span class="line">&#125;</span><br><span class="line">这种配置会让nginx报出500</span><br></pre></td></tr></table></figure>

<p>注意：<code>使用alias的时候，url后面如果加了斜杠，则下面的路径必须也加斜杠，否则403</code>。<br><strong>index</strong><br>index就是用来指定具体的资源的名字的，index可以指定多个资源的名字，第一个匹配不到，就会匹配第二个，直到匹配到为止。但是<code>location使用严格匹配的时候（加了个等于号），不能使用index，否则会导致root失效</code>，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">location =/login/&#123;</span><br><span class="line">    root    /usr/local/;</span><br><span class="line">    index    index.html;</span><br><span class="line">&#125;</span><br><span class="line">当访问的url为/login/时，实际访问的资源为：nginx的默认document_root/login/index.html，使得root失效，值得注意的是nginx的默认document_root和我们root指定的是不一样的，所以最后会404</span><br></pre></td></tr></table></figure>

<p><strong>常见配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">########### 每个指令必须有分号结束。#################</span><br><span class="line">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><br><span class="line">#worker_processes 2;  #允许生成的进程数，默认为1</span><br><span class="line">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="line">error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class="line">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class="line">    worker_connections  1024;    #最大连接数，默认为512</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class="line">    #access_log off; #取消服务日志    </span><br><span class="line">    log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #自定义格式</span><br><span class="line">    access_log log/access.log myFormat;  #combined为日志格式的默认值</span><br><span class="line">    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line"></span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  #热备</span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; #错误页</span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">        listen       4545;   #监听端口</span><br><span class="line">        server_name  127.0.0.1;   #监听地址       </span><br><span class="line">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line">           #root path;  #根目录</span><br><span class="line">           #index vv.txt;  #设置默认页</span><br><span class="line">           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表</span><br><span class="line">           deny 127.0.0.1;  #拒绝的ip</span><br><span class="line">           allow 172.18.5.54; #允许的ip           </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>startup.bat启动Tomcat闪退问题原因及解决</title>
    <url>/2020/09/29/startup.bat%E5%90%AF%E5%8A%A8Tomcat%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>安装了Tomcat之后，开始用着还好好的。<code>莫名其妙</code>的就很突然出现了一些玄学问题，某一次开始我双击了<code>startup.bat</code>启动Tomcat时我的黑窗口就很不给面子的运行着运行着就<code>闪退</code>了，隐约间能看到个异常，可刚看清楚一个<code>caused by...</code>黑窗口就已经关闭了。经历了重启电脑等常规解决问题的思路后依旧无法解决。</p>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>既然问题出现在这个启动后闪退，那就去看一眼启动时都做了什么？用记事本打开<code>startup.bat</code>，会发现一行脚本是这样写的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">set &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;</span><br></pre></td></tr></table></figure>

<p>看得出它访问了本目录下的<code>catalina.bat</code>脚本，那就记事本打开<code>catalina.bat</code>，此时又发现里面出现了这些内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">rem Get standard Java environment variables</span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot; goto okSetclasspath</span><br><span class="line">echo Cannot find &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot;</span><br><span class="line">echo This file is needed to run this program</span><br><span class="line">goto end</span><br><span class="line">:okSetclasspath</span><br><span class="line">call &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot; %1</span><br><span class="line">if errorlevel 1 goto end</span><br></pre></td></tr></table></figure>

<p>这说明<code>catalina.bat</code>又访问了该目录下的<code>setclasspath.bat</code>，而记事本打开<code>setclasspath.bat</code>后又发现它又访问了<code>catalina.bat</code>。</p>
<hr/>

<p>综上发现<code>startup.bat启动流程</code>为：<code>startup-&gt;catalina-&gt;setclasspath-&gt;catalina</code></p>
<p><img src="http://qn.mfei.fun/img/QQH2E%7B7[T[W9X%L@PK%7B1RFD.hc" alt="img"></p>
<h3 id="闪退原因："><a href="#闪退原因：" class="headerlink" title="闪退原因："></a>闪退原因：</h3><p>可见这三个文件一个都不能出问题。分析这三个文件得出闪退问题主要原因</p>
<h4 id="原因一：java环境变量出问题了"><a href="#原因一：java环境变量出问题了" class="headerlink" title="原因一：java环境变量出问题了"></a>原因一：java<a href="https://so.csdn.net/so/search?q=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">环境变量</a>出问题了</h4><p>从启动脚本中看得出Tomcat多次访问了环境变量信息，其中也包括java环境（毕竟Tomcat原码也是java啊）。故要先去<code>检查jdk的环境配置</code>。</p>
<p><strong>注意：</strong><code>CATALINA_HOME</code>是Tomcat的环境，你可以选择不配置，不过这样的话你就只能在bin目录下启动Tomcat了，换句话来讲，配置完Tomcat环境后你可以把<code>startup.bat</code>复制到其他地方双击启动。</p>
<h4 id="原因二：端口占用"><a href="#原因二：端口占用" class="headerlink" title="原因二：端口占用"></a>原因二：端口占用</h4><p>如果Tomcat已经被启动或者8080端口被占用，这自然是不允许的。</p>
<p>你可以直接访问<code>localhost:8080</code>看能否访问Tomcat，如果可以那就说明是已经开启过了的，你可以双击<code>shutdown.bat</code>进行关闭。</p>
<p>或者你可以在黑窗口中执行<code>netstat -ano | findstr &quot;8080&quot;</code>查看8080端口状态，如果是<code>TIME_WAIT</code>则说明未被占用。</p>
<h4 id="原因三：你的Tomcat不干净了"><a href="#原因三：你的Tomcat不干净了" class="headerlink" title="原因三：你的Tomcat不干净了"></a>原因三：你的Tomcat不干净了</h4><p>到现在还没解决，那就有可能是你所下载的Tomcat是一些<code>绿色版、无敌版、xx版</code>等阉货或畸形货。此时就可在记事本打开<code>startup.bat</code>，在脚本最后面一行加上<code>pause</code>，保存后启动进行断点调试了。（不一定非得像我图片中加在倒数第二行，最后一行应该也可以，只要不放在前面的逻辑中就行）。</p>
<p><img src="http://qn.mfei.fun/img/@UTBWFW8Z3]27P7OU7%FXQW.hc" alt="img"></p>
<p>此时启动效果和之前没有区别，只是出了问题后不再会立刻闪退，而是你在窗口中按任意键后才会退出。OK！现在你就研究属于你的bug吧（记得解决完问题后把pause删掉）！</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理与反向代理</title>
    <url>/2020/08/27/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><ol>
<li>当你想要访问一些网站时，发现时而能进时而又不能，就比如…<a href="https://pixivic.com/?VNK=90f826db">pixivic</a>、GitHub，或是想要访问YouTube等。此时你会怎么做？</li>
<li>我们的服务部署在服务器上，本可以通过主机IP、服务端口号直接访问，那为什么不直接让前端通过主机或者主机域名加端口访问呢？</li>
</ol>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p><strong>原理</strong>：代理服务器是<code>独立搭建</code>的，用户将自己的请求发送给代理服务器，代理服务器将客户请求发送给目标服务器，目标服务器将请求结果响应给代理服务器，代理服务器将响应信息返回给用户。</p>
<p>![img](<a href="http://qn.mfei.fun/img/~A8%7D$[[_ZGEFJVI">http://qn.mfei.fun/img/~A8}$[[_ZGEFJVI</a>(Q</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/03/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="了解观察者模式"><a href="#了解观察者模式" class="headerlink" title="了解观察者模式"></a>了解观察者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>观察者模式（Observer Pattern）。定义对象间的一种<code>一对多的依赖关系</code>，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>张三欠了很多人钱，债主每天来要钱对谁都不好。于是就可以让张三有钱时主动通知债主，没钱时就让债主等着（债主就是观察者，观察张三有没有钱）。于是观察者模式又叫<code>发布者模式</code>。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 张三为借钱者</span></span><br><span class="line">        <span class="type">Debit</span> <span class="variable">zhangSan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DebitImpl</span>();</span><br><span class="line">        <span class="comment">// 向老板借钱</span></span><br><span class="line">        zhangSan.borrow(<span class="keyword">new</span> <span class="title class_">Boss</span>());</span><br><span class="line">        <span class="comment">// 向朋友借钱</span></span><br><span class="line">        zhangSan.borrow(<span class="keyword">new</span> <span class="title class_">Friend</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自行改变判断state为true时（有钱后）通知还钱</span></span><br><span class="line">        zhangSan.notifyCreadits();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借贷者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Debit</span>&#123;</span><br><span class="line">    <span class="comment">// 向贷款方借钱</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">(Credit credit)</span>;</span><br><span class="line">    <span class="comment">// 通知债主自己要还钱</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyCreadits</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贷款者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DebitImpl</span> <span class="keyword">implements</span> <span class="title class_">Debit</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个数据结构存放这些债主</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Credit&gt; allCredits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当为true时表示有钱，可以通知还钱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">(Credit credit)</span> &#123;</span><br><span class="line">        <span class="comment">// 每借一个人的钱就把这个人存到集合中去</span></span><br><span class="line">        allCredits.add(credit);</span><br><span class="line">        System.out.println(<span class="string">&quot;张三借钱！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyCreadits</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 还钱时直接遍历集合通知还钱</span></span><br><span class="line">        allCredits.forEach(credit -&gt; credit.takeMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贷款方（债主）接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Credit</span>&#123;</span><br><span class="line">    <span class="comment">// 债主要钱</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">takeMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> <span class="keyword">implements</span> <span class="title class_">Credit</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boss得到偿还&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Friend</span> <span class="keyword">implements</span> <span class="title class_">Credit</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Friend得到偿还&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://qn.mfei.fun/img/%7DBZ6CUEI4CJWAZASBC54W1K.png" alt="img"></p>
<h2 id="观察者模式应用"><a href="#观察者模式应用" class="headerlink" title="观察者模式应用"></a>观察者模式应用</h2><h3 id="情景使用——天气预报"><a href="#情景使用——天气预报" class="headerlink" title="情景使用——天气预报"></a>情景使用——天气预报</h3><p>描述：气象站想要把自己测量的温度、湿度、天气等信息以公告形式发布出去（如：自己的官网或QQ、微信等第三方），那么他就需要设计开放型的的API（提供温度、湿度、气压等接口），便于其他第三方也能接入气象站获取数据。测量数据更新时要能实时的通知给第三方。</p>
<p><img src="http://qn.mfei.fun/img/image-20220919152121253.png" alt="image-20220919152121253"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
</search>
